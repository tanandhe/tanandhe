[{"content":"适用群晖需要设置ipv6的ddns时，可以适用下面的脚本定时更新解析地址（计划任务）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash noip_user=\u0026#34;example@sina.com\u0026#34; noip_pass=\u0026#34;xxxxxxx\u0026#34; noip_domain=\u0026#39;example.ddns.net\u0026#39; noip_url=\u0026#39;https://dynupdate.no-ip.com/nic/update\u0026#39; ipv6=`ip addr show eth0 | grep \u0026#34;inet6.*global\u0026#34; | awk \u0026#39;{print $2}\u0026#39; | awk -F\u0026#34;/\u0026#34; \u0026#39;{print $1}\u0026#39;` current_ipv6=`nslookup -query=AAAA $noip_domain 2\u0026gt;\u0026amp;1` current_ipv6=`echo \u0026#34;$current_ipv6\u0026#34; | grep \u0026#39;Address: \u0026#39; | tail -n1 | awk \u0026#39;{print $NF}\u0026#39;` echo \u0026#39;-----------------\u0026#39; $ipv6 echo \u0026#39;-----------------\u0026#39; $current_ipv6 noip_data=\u0026#34;?hostname=$noip_domain\u0026amp;myip=$ipv6\u0026#34; noip_head=$(echo $noip_user:$noip_pass | base64) if [ \u0026#34;$ipv6\u0026#34; = \u0026#34;$current_ipv6\u0026#34; ] then echo \u0026#39;-----------------\u0026#39; \u0026#34;Skipping\u0026#34; else curl -H \u0026#34;Authorization: Basic $noip_head\u0026#34; -s \u0026#34;$noip_url$noip_data\u0026#34; echo \u0026#39;-----------------\u0026#39; \u0026#34;Updated record $ipv6\u0026#34; fi ","date":"2024-10-08T16:07:07+08:00","permalink":"https://www.hackctf.com/p/ddns%E6%9B%B4%E6%96%B0ipv6%E5%9C%B0%E5%9D%80/","title":"ddns更新IPv6地址"},{"content":"\r#\r外部程序如何通过novnc访问proxmox的虚拟机\r#\r1. proxmox工作原理\rproxmox虚拟化平台管理界面可以通过novnc连接虚拟机，web管理页面基本都是通过api完成相关功能的，具体api文档可以点击右上角“documentation”查看：\nnovnc连接的步骤如下：\n1.通过API:/api2/json/nodes/pve/qemu/105/vncproxy获取vnc的ticket\n2.novnc通过websocket建立连接\nwebsocket建立成功有一下几点注意的地方：\n1.每个vnc的ticket只能建立一次连接，无论失败成功，再次使用无法建立连接报bad handshake错误\n2.websocket连接请求中需要携带PVEAuthCookie,值是pve的认证ticket，proxmox系统登录后或者通过api获得（/api2/json/access/ticket）\n3.连接过程中novnc需要输入密码，密码就是：vncticket的值(不能url编码)，proxmox前端自动填入密码登录，因此登录过程未出现输入密码的过程。\n4.PVEAuthCookie和ticket必须使用url编码\n#\r2.外部调用\r开发第三方应用如何将novnc嵌入访问proxmox的虚拟机资源，就要满足websocket建立的三个条件\n#\r1.nginx代理\r将第三方应用和proxmox管理页面用nginx代理到同一IP地址下，实现同源，这样访问时就可以自动携带PVEAuthCookie，这种方式的优势是不需要后端处理，前端模仿proxmox连接vnc的过程就可以。\n缺点是：暴露了PVEAuthCookie，用户可以通过该值直接登录proxmox或者通过api控制proxmox，存在安全极大安全风险。\n#\r2.websocket代理\r这种方式实现的原理是，websocket代理转发客户端和proxmox之间的连接流量，proxmox认证需要的信息由代理生成：\n客户端\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;（websocket）\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;代理\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;（websocket）\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-proxmox\n#\r2.1 获取pve的token\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 type LoginResponse struct { Data struct { CSRFPreventionToken string `json:\u0026#34;CSRFPreventionToken\u0026#34;` Ticket string `json:\u0026#34;ticket\u0026#34;` } `json:\u0026#34;data\u0026#34;` } func LoginProxmox(url, username, password string) (string, string, error) { // url := \u0026#34;https://192.168.100.5:8006/api2/json/access/ticket\u0026#34; loginData := map[string]string{ \u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password, } jsonData, _ := json.Marshal(loginData) req, _ := http.NewRequest(\u0026#34;POST\u0026#34;, url, bytes.NewBuffer(jsonData)) req.Header.Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) client := \u0026amp;http.Client{ Transport: \u0026amp;http.Transport{ TLSClientConfig: \u0026amp;tls.Config{InsecureSkipVerify: true}, // 忽略证书验证 }, } resp, err := client.Do(req) if err != nil { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, err } defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) var loginResp LoginResponse err = json.Unmarshal(body, \u0026amp;loginResp) if err != nil { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, err } return loginResp.Data.Ticket, loginResp.Data.CSRFPreventionToken, nil } #\r2.2 获取vnc的ticket\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 type VncResponse struct { Data struct { Ticket string `json:\u0026#34;ticket\u0026#34;` Port string `json:\u0026#34;port\u0026#34;` User string `json:\u0026#34;user\u0026#34;` Upid string `json:\u0026#34;upid\u0026#34;` Cert string `json:\u0026#34;cert\u0026#34;` } `json:\u0026#34;data\u0026#34;` } func GetVncTicket(url, ticket, csrfToken string) (VncResponse, error) { // url := fmt.Sprintf(\u0026#34;https://192.168.100.5:8006/api2/json/nodes/%s/qemu/%s/vncproxy\u0026#34;, node, vmid) // loginData := map[string]int{ // \u0026#34;websocket\u0026#34;: 1, // } // jsonData, _ := json.Marshal(loginData) req, _ := http.NewRequest(\u0026#34;POST\u0026#34;, url, nil) req.Header.Set(\u0026#34;Cookie\u0026#34;, \u0026#34;PVEAuthCookie=\u0026#34;+ticket) req.Header.Set(\u0026#34;csrfpreventiontoken\u0026#34;, csrfToken) client := \u0026amp;http.Client{ Transport: \u0026amp;http.Transport{ TLSClientConfig: \u0026amp;tls.Config{InsecureSkipVerify: true}, // 忽略证书验证 }, } resp, err := client.Do(req) if err != nil { return VncResponse{}, err } defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) var vncResp VncResponse err = json.Unmarshal(body, \u0026amp;vncResp) if err != nil { return VncResponse{}, err } return vncResp, nil } #\r2.3 建立websocket转发\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 // 代理 WebSocket 连接 func (app *App) proxyWebSocket(w http.ResponseWriter, r *http.Request, port string, vncticket string) { // 升级客户端请求为 WebSocket 连接 clientConn, err := upgrader.Upgrade(w, r, nil) if err != nil { http.Error(w, \u0026#34;Failed to upgrade to WebSocket\u0026#34;, http.StatusBadRequest) log.Println(\u0026#34;WebSocket upgrade error:\u0026#34;, err) return } defer clientConn.Close() //更新vncTicket vncurl := fmt.Sprintf(\u0026#34;https://192.168.100.5:8006/api2/json/nodes/%s/qemu/%d/vncproxy\u0026#34;, \u0026#34;pve\u0026#34;, 105) var vncRes pve.VncResponse vncRes, err = pve.GetVncTicket(vncurl, app.ticket, app.csrf) if err != nil { log.Fatal(err) } // 构造 Proxmox VNC WebSocket URL proxmoxURL := url.URL{ Scheme: \u0026#34;wss\u0026#34;, Host: \u0026#34;192.168.100.5:8006\u0026#34;, Path: \u0026#34;/api2/json/nodes/pve/qemu/105/vncwebsocket\u0026#34;, // 替换 \u0026lt;node\u0026gt; 和 \u0026lt;vmid\u0026gt; 为实际值 RawQuery: fmt.Sprintf(\u0026#34;port=%s\u0026amp;vncticket=%s\u0026#34;, app.port, url.QueryEscape(vncRes.Data.Ticket)), } dialer := websocket.Dialer{ TLSClientConfig: \u0026amp;tls.Config{InsecureSkipVerify: true}, // 忽略证书验证 Subprotocols: []string{\u0026#34;binary\u0026#34;}, } headers := http.Header{} headers.Add(\u0026#34;Cookie\u0026#34;, \u0026#34;PVEAuthCookie=\u0026#34;+url.QueryEscape(app.ticket)) // headers.Add(\u0026#34;csrfpreventiontoken\u0026#34;, app.csrf) // 连接到 Proxmox WebSocket log.Println(\u0026#34;URL:\u0026#34;, proxmoxURL.String()) proxmoxConn, _, err := dialer.Dial(proxmoxURL.String(), headers) if err != nil { http.Error(w, \u0026#34;Failed to connect to Proxmox\u0026#34;, http.StatusInternalServerError) log.Println(\u0026#34;Proxmox WebSocket connection error:\u0026#34;, err) return } defer proxmoxConn.Close() // 启动客户端和 Proxmox 之间的双向数据传输 done := make(chan struct{}) // 从客户端到 Proxmox go func() { defer close(done) for { messageType, message, err := clientConn.ReadMessage() if err != nil { log.Println(\u0026#34;Client read error:\u0026#34;, err) return } err = proxmoxConn.WriteMessage(messageType, message) if err != nil { log.Println(\u0026#34;Proxmox write error:\u0026#34;, err) return } } }() // 从 Proxmox 到客户端 go func() { for { messageType, message, err := proxmoxConn.ReadMessage() if err != nil { log.Println(\u0026#34;Proxmox read error:\u0026#34;, err) clientConn.WriteMessage(websocket.CloseMessage, websocket.FormatCloseMessage(websocket.CloseNormalClosure, \u0026#34;\u0026#34;)) return } err = clientConn.WriteMessage(messageType, message) if err != nil { log.Println(\u0026#34;Client write error:\u0026#34;, err) return } } }() // 等待传输完成 \u0026lt;-done } #\r2.4 代理端口监听和处理\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func (app *App) Handler(w http.ResponseWriter, r *http.Request) { // 假设从请求中获取端口和 vncticket（也可以从 Proxmox API 获取） port := r.URL.Query().Get(\u0026#34;port\u0026#34;) vncticket := r.URL.Query().Get(\u0026#34;vncticket\u0026#34;) log.Println(vncticket) log.Println(port) if port == \u0026#34;\u0026#34; || vncticket == \u0026#34;\u0026#34; { http.Error(w, \u0026#34;Missing port or vncticket in query parameters\u0026#34;, http.StatusBadRequest) return } app.proxyWebSocket(w, r, port, vncticket) } -------------------------------------------- # main.go http.HandleFunc(\u0026#34;/\u0026#34;, app.Handler) log.Println(\u0026#34;WebSocket Proxy Server started at :8080\u0026#34;) err = http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) if err != nil { log.Fatal(\u0026#34;ListenAndServe: \u0026#34;, err) } #\r2.5 novnc连接\r由于程序测试的缘故，需要提供路径参数，点击连接后出现密码输入框:\n输入vncticket：PVEVNC:66F13904::KCOiBbp61SRDoRPfuJCU0dSiOTddunbMSmoNwIIlNvooFtbJO/BMscu7l61a83rr3PH8kOjvaXRxgHZRL24FvRFc5KZKLQsFcok0 rsB1QdLceiX05xVkhInHqCWbPSNKZy5j4cIzQZGCVNfFOcEZNFMSNzGJGEdxQ/6F9jYsJMvnyxIKHff90RIHtupvKWpn1Ou3pdWKX2BbnT20mHHLogxdLKlMxXbHYJ/ia/6WHKBUBaYTQwReH7K0mmSmElJXQW3iit R0FA52uMwS1sBG5Gl0WJWmWzcA8EnPV6wID0w/P 9NaG8Cd1C6XdUghsKaIj0wz0p2DJSDlfzymdLA==\n连接成功\n这种方法的缺点是后端的编程工作量稍大，但是由于代理的存在，用户端无需获得proxmox相关凭证，不会对proxmox造成安全威胁，后续业务逻辑处理起来也更加灵活。\n#\r3.结束语\r本文介绍了最关键的novnc的代理方式，第三方应用如果想控制proxmox实现开关机、新建等功能也可以通过类似的的方式后端程序通过api进行控制proxmox。\n","date":"2024-09-24T08:46:15+08:00","permalink":"https://www.hackctf.com/p/%E5%A4%96%E9%83%A8%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87novnc%E8%AE%BF%E9%97%AEproxmox%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"外部程序如何通过novnc访问proxmox的虚拟机"},{"content":"\r#\r如何给PVE中的虚拟机增加不限速的网卡\r#\r1.给PVE安装openvswitch-switch服务\r1 apt install openvswitch-switch -y 安装好后查看配置命令：ovs-vsctl show\n#\r2.在PVE中建立OVS Bridge\r没有物理端口可以先不填\n#\r3.在虚拟机中添加virto类型的网卡\r#\r4.如果是window需要安装virtio-win的驱动\r挂载驱动镜像\n在计算机管理-》设备管理中找到驱动有问题的网卡硬件，更新驱动\n选择浏览计算机\n选择光盘\n#\r5. 成功驱动网卡\r状态显示网卡速度为100G bps\n![(images/1718531247635.png)\n","date":"2024-06-16T17:35:37+08:00","permalink":"https://www.hackctf.com/p/%E5%A6%82%E4%BD%95%E7%BB%99pve%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A2%9E%E5%8A%A0%E4%B8%8D%E9%99%90%E9%80%9F%E7%9A%84%E7%BD%91%E5%8D%A1/","title":"如何给pve虚拟机增加不限速的网卡"},{"content":"在PCB电路板中加入一些个性化的logo图案既美观，又可以起到宣传的效果，logo和焊盘一样，金属裸露在外，如果使用沉金工艺效果更加惊艳。比如下面是picoclick的电路板，如何在嘉立创EDA中实现这一效果呢？\n实现思路：以顶层为例，需要将logo在顶层有铜层的同时不能有顶层的阻焊层，和焊盘一样。 以顶层创建裸露金属为例子，\n#\r1第一步，导入顶层图片\r首先要在顶层导入要创建logo的图片，图片要进行二值化处理，否则程序可能识别不准确\n如果处于顶层编辑状态，导入默认位于顶层，如果不是修改图片属性为“顶层”\n为了方便在3D中查看为pcb板画一个板框用来定义pcb的形状。\n此时，预览3D效果，发现二维码上有阻焊层，就是pcb板导线上面的绿油\n#\r2.去除阻焊层，实现铜皮裸露\r复制导入的二维码图片，然后调整复制后的图片板层为：顶层阻焊层（如果是在底层则选择底层阻焊层）\n查看原图片的位置信息修改，新图片位置和原图完全重合\n然后，3D预览发现，铜皮就裸露出来了\n","date":"2024-05-09T22:45:17+08:00","permalink":"https://www.hackctf.com/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E5%9C%A8%E7%AB%8B%E5%88%9Beda%E4%B8%AD%E5%88%B6%E4%BD%9C%E8%A3%B8%E9%9C%B2%E9%87%91%E5%B1%9E%E7%84%8A%E7%9B%98/","title":"如何使用图片在立创EDA中制作裸露金属焊盘"},{"content":"基于hugo的个人博客创建好了，可以添加一个百度的网站统计功能，用来了解自己博客的访问情况\n#\r1.注册一个“百度统计”账户\r百度统计官方网站：https://tongji.baidu.com/\n打开使用设置，新建网站\n创建好之后点击“获取代码”\n获得百度统计的javascript代码，复制\n#\r2.在hugo个人博客中加入代码\r统计代码最好在每个页面中都加入，这样统计才比较全面，我们在hugo主题中footer.html中加入，这样就可以保证每个页面都被监控到。\n我使用的stack主题修改的路径如下，不同主题应该也差不多。\n#\r3.测试页面统计功能\r俩种方法检查统计页面代码是否生效：\n1.百度自带的代码检查\n如果部署在github上可能由于网络的原因失败，多试几次就好了\n2.自己手工检查,在博客标签页打开“开发者工具”，看代码是否已经正确加载\n刷新页面看网络请求是否包含百度\n#\r4.查看网站的统计情况\r统计功能还是非常丰富的，有实时访问流量、来源、IP地址等，让我们对自己的博客访问情况了如执掌。\n","date":"2024-04-24T09:48:42+08:00","permalink":"https://www.hackctf.com/p/%E7%BB%99hugo%E5%8A%A0%E4%B8%AA%E7%BD%91%E7%AB%99%E5%A2%9E%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD/","title":"给hugo加个网站增加百度统计功能"},{"content":"phpipam是一套开源的IP地址管理工具\n官方网站：phpIPAM IPAM IP address management software\n系统使用PHP开发，官方文档安装教程基于Centos7、debian，由于安装的php扩展多，自己在Centos下反复折腾无法安装php-pear，最后放弃，而且官方的演示网站也由于php-pear扩展的问题挂掉了，因此尝试使用docker进行部署。\n这么好的项目，看样子也要。。。\n系统需要的docker环境：\n1 2 3 数据库：mysql 前端： phpipam_www 后端定时任务：phpipam_cron(这个据github介绍是后端的扫描程序，使用过程中还没发现有什么用，可能定期扫描IP地址吧) 部署后docker截图：\nphpipam系统截图：\n为了方便使用docker先部署了portainer进行图形化的管理docker，主要是设置一些启动参数方便，具体部署方法可以参照之前的文章。常用docker配置 (hackctf.com)\n#\r1.mysql部署\r搜索拉取镜像\n1 2 docker search mysql docker pull mysql portainer中设置端口映射和环境变量，不设置环境变量，docker会报错无法启动，日志中有提示三种设置环境变量的方法，我选择直接使用root密码。\n1 MYSQL_ROOTPASSWORD= XXXXXX 特别注意：mysql版本是8.3，部分mysql连接工具无法连接，比如我的navicat\n登录测试没问题：\n#\r2.phpipam_www部署\r拉取镜像\n1 docker search phpipam_www 设置环境变量和端口映射\n如果不设置直接访问web页面也可以出现安装界面，但是选择自动安装数据库的地址默认是127.0.0.1无法修改\n访问phpipam，出现安装界面，选择1，全新安装\n选择1自动安装：\n设置数据库信息：\n下一步，设置管理员密码：\n返回登录页面：\n安装完成\n注意事项：使用手工安装的时候系统系统默认的用户名密码是：\n1 2 用户名：Admin\t密码： ipamadmin #\r3. phpipam_cron部署\r设置环境变量，不需要映射网络，这个容器具体功能以后使用中在摸索吧，目前还没了解太明白。\n","date":"2024-04-24T08:27:10+08:00","permalink":"https://www.hackctf.com/p/%E4%BD%BF%E7%94%A8docker%E9%83%A8%E7%BD%B2phpipam/","title":"使用docker部署phpipam"},{"content":"\r#\rgithub pages 不能识别下划线开头的文件\r使用sphinx创建的文档，资源文件夹前面会带着下划线，本地使用没有问题，提交到github上面，想使用github pages的时候提示404，原因为github pages的jekyll模版会忽略下划线开头的文件，所以要禁用jekyll 禁用方法就是在项目根目录下添加一个空白文件，命名为：.nojekyll\n","date":"2024-04-18T16:27:20+08:00","permalink":"https://www.hackctf.com/p/%E4%B8%8B%E5%88%92%E7%BA%BF%E5%BC%80%E5%A4%B4%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%A8github%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%98%BE%E7%A4%BA%E4%B8%8D%E6%AD%A3%E5%B8%B8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","title":"下划线开头的图片在github页面中显示不正常解决方法"},{"content":"\r#\r常用docker配置安装\r#\r1.安装portainer\r#\r1.1 搜索portainer\r#\r1.2 拉取容器镜像\r#\r1.3启动容器\r1 docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v /home/abolo/docker/portainer:/data --restart=always --name portainer portainer/portainer-ce:latest #\r1.4首次登录设置用户名密码\r#\r2. 安装Node-RED\r#\r2.1搜索容器镜像\r1 docker search node-red #\r2.2 拉取容器\r1 docker pull nodered/node-red #\r2.3启动容器\r1 docker run -d -p 1880:1880/tcp -v /home/abolo/docker/node_red:/data --name nodered nodered/node-red:latest #\r2.4修改npm软件镜像源\r#\r2.4.1 进入docker\r1 docker #\r2.4.2修改npm镜像源\r1 npm config set registry http://mirrors.cloud.tencent.com/npm/ #\r2.5安装homeassistant包\r节点管理\n搜索homeassistant的功能包\n安装后重启docker，面板首页出现homeassistant功能模块\n#\r3.安装emqx\r#\r3.1搜索容器镜像\r#\r3.2拉取容器\r#\r3.3启动容器\r1 docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx #\r3.4访问容器\r管理页面端口：18083\n默认的用户名密码： admin public\n#\r3.5设置客户端认证\r#\r3.6添加用户\r#\r3.7客户端连接测试\r#\r4.安装homeassistant\r#\r4.1搜索镜像\r#\r4.2拉取镜像\r#\r4.3启动容器\r1 2 3 4 5 6 7 docker run -d \\ --restart always \\ --name homeassistant \\ -v /home/abolo/docker/hass/config:/config \\ -e TZ=Asia/Shanghai \\ -p 8123:8123 \\ homeassistant/home-assistant:latest #\r4.4首次访问\r默认端口：8123\n设置用户名密码，进入系统\n#\r4.5安装HACS插件\r#\r4.5.1 下载hacs插件\r1 https://github.com/hacs/integration/releases/ #\r4.5.2 上传hacs.zip至config/custom_components/hacs目录，并解压\runzip hacs.zip\n#\r4.5.3重新启动homeassistant\r打开集成添加hacs\n打开github输入设备码\n此处可能需要翻墙，保证github可达，安装成功\n#\r5.安装树莓派视频监控motion\r#\r5.1 安装motion软件\r#\r5.2修改motion配置\r默认最大码流是1，修改后码流较为顺畅\n1 stream_maxrate 15 如果不存在改设置项，可以通过管理也页面生成完整当前配置选项\n配置motion的视频存储位置\n#\r6.docker修改镜像存储目录\r","date":"2024-04-18T13:59:43+08:00","permalink":"https://www.hackctf.com/p/%E5%B8%B8%E7%94%A8docker%E9%85%8D%E7%BD%AE/","title":"常用docker配置"},{"content":"\r#\r如何使用hugo建立自己的个人网站\r#\r1.安装hugo程序\rgithub找到hugo的托管网站\n下载hugo程序，路径添加到系统的环境变量中\n#\r2.创建一个新站点\r1 2 hugo new site mysite #hugo new site [path] [flags] #\r3.安装主题\r本博客选择的主题是CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers (github.com)\n1 https://github.com/CaiJimmy/hugo-theme-stack 下载主题至hugo网站的themes文件夹\n然后复制主题配置文件至博客根目录\n#\r4.运行编译静态网站\r1 2 hugo -D //编译生成静态网站 hugo server //启动本地服务，默认是本机1313端口，访问连接：http://127.0.0.1:1313 #\rTIPS:\r将域名通过CNAME解析到github pages时，需要在网站根目录下创建一个名称为“CNAME”的文件，文件内容如下：\n1 2 www.hackctf.com hackctf.com 否则，访问tanandhe.github.io正常，访问www.hackctf.com提示404，设置完毕后需要等待1-2分钟，使得配置生效。\n#\r5.官方文档\rhugo官方文档：https://gohugo.io/getting-started/quick-start/ stack主题的官方文档：https://stack.jimmycai.com/writing/markdown\n","date":"2024-04-16T17:36:15+08:00","permalink":"https://www.hackctf.com/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E5%88%B6%E4%BD%9C%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/","title":"如何使用hugo制作个人静态网站"},{"content":"\r#\r部署hugo的静态网页至github\r#\r第一步：编译静态页面\r1 2 3 #编译静态网站 hugo #hugo --baseUrl=\u0026#34;https://www.hackctf.com/\u0026#34; #\r第二步：上传github\r1 2 3 4 5 6 7 cd public git init git remote add origin https://github.com/tanandhe/tanandhe.github.io.git git add -A git commit -m \u0026#34;First commit\u0026#34; git push -u origin master #第一次提交时需要认证 #git push -f -u origin master //可以强行覆盖 ","date":"2024-04-16T16:58:29+08:00","permalink":"https://www.hackctf.com/p/%E9%83%A8%E7%BD%B2hugo%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E8%87%B3github-pages/","title":"部署hugo静态网站至github pages"},{"content":"\r#\r正文测试\r而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n#\r引用\r思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n#\r图片\r1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://www.hackctf.com/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.hackctf.com/p/test-chinese/","title":"Chinese Test"}]